(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{981:function(_,v,p){"use strict";p.r(v);var e=p(6),t=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"postregsql"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#postregsql"}},[_._v("#")]),_._v(" POSTREGSQL")]),_._v(" "),v("h2",{attrs:{id:"postgresql中mvcc表膨胀问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#postgresql中mvcc表膨胀问题"}},[_._v("#")]),_._v(" postgresql中mvcc表膨胀问题")]),_._v(" "),v("p",[_._v("pg中的mvcc\n旧版本和新版本在同一个数据库的问题")]),_._v(" "),v("p",[_._v("行发生了修改就有新版本和旧版本，存在同样的数据文件里面，如果垃圾回收不及时，就会发生表膨胀")]),_._v(" "),v("p",[_._v("技术原理")]),_._v(" "),v("p",[_._v("存储旧版本：解决并发事务，方便查询旧的版本数据")]),_._v(" "),v("p",[_._v("影响范围，行业，业务")]),_._v(" "),v("p",[_._v("对于高频率的更新，插入，删除场景就会有问题")]),_._v(" "),v("p",[_._v("传感器，出租车位置，等更新多的场景，容易出问题，垃圾回收不及时，就会膨胀")]),_._v(" "),v("p",[_._v("什么时候回收不及时")]),_._v(" "),v("p",[_._v("看看有没有2pc")]),_._v(" "),v("p",[_._v("看看垃圾回收设置的内存是不是过小")]),_._v(" "),v("p",[_._v("垃圾回收工作进程太少了")]),_._v(" "),v("p",[_._v("磁盘性能")]),_._v(" "),v("p",[_._v("膨胀之后会有什么问题")]),_._v(" "),v("p",[_._v("1.存储空间不足")]),_._v(" "),v("p",[_._v("2.访问的时候io的范围会增加，本来访问一个数据块的现在需要访问2，3个数据块了")]),_._v(" "),v("p",[_._v("3.内存的消耗增加了，因为内存buffer要去缓存block")]),_._v(" "),v("p",[_._v("4.性能下降")]),_._v(" "),v("p",[_._v("解决：")]),_._v(" "),v("p",[_._v("设置参数\nhttps://blog.csdn.net/weixin_34360651/article/details/90504302")]),_._v(" "),v("p",[_._v("表膨胀解决方法")]),_._v(" "),v("p",[_._v("https://ctypyb2002.blog.csdn.net/article/details/82774684?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.control")]),_._v(" "),v("p",[_._v("新引入的问题")]),_._v(" "),v("p",[_._v("1、需要io延时更低的硬盘")]),_._v(" "),v("p",[_._v("2、牺牲了长事务")]),_._v(" "),v("p",[_._v("3、需要增加监控项")]),_._v(" "),v("p",[_._v("有没有希望解决这个坑")]),_._v(" "),v("p",[_._v("基于专门的回归段的存储引擎")]),_._v(" "),v("h2",{attrs:{id:"pg-local-memory"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pg-local-memory"}},[_._v("#")]),_._v(" pg local memory")]),_._v(" "),v("p",[_._v("plan cachae")]),_._v(" "),v("p",[_._v("背后原理：")]),_._v(" "),v("p",[_._v("sql执行的几个阶段")]),_._v(" "),v("p",[_._v("​\t1解析：有没有语法错误，规整化")]),_._v(" "),v("p",[_._v("​\t2query的rewrit")]),_._v(" "),v("p",[_._v("前面")]),_._v(" "),v("p",[_._v("解析计划")]),_._v(" "),v("p",[_._v("执行")]),_._v(" "),v("p",[_._v("在会话里面是私有的")]),_._v(" "),v("p",[_._v("影响行业")]),_._v(" "),v("p",[_._v("1SaaS")]),_._v(" "),v("p",[_._v("2分区超多的场景，要使用长连接的场景")]),_._v(" "),v("p",[_._v("3微服务")]),_._v(" "),v("p",[_._v("使用local memory带来的问题")]),_._v(" "),v("p",[_._v("saas：提供软件服务，有一套独立的schema，服务1w家企业的话有可能有1w个schema，每个schema可能有上万的表或对象，就很多了")]),_._v(" "),v("p",[_._v("一个会话生命周期内访问很多表，数据库对象，就会产生很多的loacl cache就是local 的memory包括plan cache,占用的内存会越来越大，最后导致omm")]),_._v(" "),v("p",[_._v("分区超多，要使用长连接，")]),_._v(" "),v("p",[_._v("频繁更新c端的业务系统通常就有这些特性，比如共享单车数量多，用户多，通过分区提高freeze的效率，一个连接可能到")]),_._v(" "),v("p",[_._v("很多的分区，消耗的内存就很多")]),_._v(" "),v("p",[_._v("微服务")]),_._v(" "),v("p",[_._v("对业务灵活，对于数据库来将，每一个服务都要跟数据库产生连接")]),_._v(" "),v("p",[_._v("业务上如何避免这个坑")]),_._v(" "),v("p",[_._v("1、设置会话的连接生命周期，避免长时间使用过多的对象")]),_._v(" "),v("p",[_._v("2、控制总的连接数")]),_._v(" "),v("p",[_._v("3、避免访问分区过度，原始的即便访问分区，也要把所有的全部touch出来")]),_._v(" "),v("p",[_._v("4、创建一个中间连接池，控制总的连接数，pgbouncer（牺牲短频快）")]),_._v(" "),v("p",[_._v("会引入什么新的问题，产生什么样的牺牲")]),_._v(" "),v("p",[_._v("1.增加复杂度")]),_._v(" "),v("p",[_._v("2.微服务很多的时候控制总连接数")]),_._v(" "),v("p",[_._v("未来")]),_._v(" "),v("p",[_._v("1.内置线程池")]),_._v(" "),v("p",[_._v("2.local memory作成global memory")]),_._v(" "),v("h2",{attrs:{id:"pg-log-statement参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pg-log-statement参数"}},[_._v("#")]),_._v(" pg log_statement参数")]),_._v(" "),v("p",[_._v("读取数据块的时候会占用2份内存")]),_._v(" "),v("p",[_._v("缓存，就是内存会在os的page cache和数据库的buffer库里面会体现出来")]),_._v(" "),v("p",[_._v("存在内存浪费")]),_._v(" "),v("p",[_._v("技术原理")]),_._v(" "),v("p",[_._v("pg写操作用了buffer IO 的接口，到os层会产生缓存，最后由io子系统写入到块设备里面去")]),_._v(" "),v("p",[_._v("读操作类似")]),_._v(" "),v("p",[_._v("影响行业导致问题")]),_._v(" "),v("p",[_._v("所有")]),_._v(" "),v("p",[_._v("内存浪费")]),_._v(" "),v("p",[_._v("os的buffer IO,调度配置不好的话，对导致大量IO,IO hang，导致checkpoin，和别的的读数据的响应时间")]),_._v(" "),v("p",[_._v("始终要过一次层os cache")]),_._v(" "),v("p",[_._v("解决方法")]),_._v(" "),v("p",[_._v("好处")]),_._v(" "),v("p",[_._v("1.会在os层合并之后在写入，减少总的io次数")]),_._v(" "),v("p",[_._v("2.数据库在重启的时候可以缓冲一下,在发起读请求的时候其实是从os层面cache读出来的，（业务繁忙的时候，挂了，重启的场景）")]),_._v(" "),v("p",[_._v("3.刷盘，checkpoint")]),_._v(" "),v("p",[_._v("避免")]),_._v(" "),v("p",[_._v("无解")]),_._v(" "),v("p",[_._v("配置较大的shared buffer")]),_._v(" "),v("p",[_._v("shared_buffer")]),_._v(" "),v("p",[_._v("设置为物理内存的25%，服务器的内存为8G，故将此选项设置为1G：")]),_._v(" "),v("p",[_._v("shared_buffers = 2048MB")]),_._v(" "),v("h2",{attrs:{id:"pg-double-cache"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pg-double-cache"}},[_._v("#")]),_._v(" pg double cache")]),_._v(" "),v("p",[_._v("读取数据块的时候会占用2份内存")]),_._v(" "),v("p",[_._v("缓存，就是内存会在os的page cache和数据库的buffer库里面会体现出来")]),_._v(" "),v("p",[_._v("存在内存浪费")]),_._v(" "),v("p",[_._v("技术原理")]),_._v(" "),v("p",[_._v("pg写操作用了buffer IO 的接口，到os层会产生缓存，最后由io子系统写入到块设备里面去")]),_._v(" "),v("p",[_._v("读操作类似")]),_._v(" "),v("p",[_._v("影响行业导致问题")]),_._v(" "),v("p",[_._v("所有")]),_._v(" "),v("p",[_._v("内存浪费")]),_._v(" "),v("p",[_._v("os的buffer IO,调度配置不好的话，对导致大量IO,IO hang，导致checkpoin，和别的的读数据的响应时间")]),_._v(" "),v("p",[_._v("始终要过一次层os cache")]),_._v(" "),v("p",[_._v("解决方法")]),_._v(" "),v("p",[_._v("好处")]),_._v(" "),v("p",[_._v("1.会在os层合并之后在写入，减少总的io次数")]),_._v(" "),v("p",[_._v("2.数据库在重启的时候可以缓冲一下,在发起读请求的时候其实是从os层面cache读出来的，（业务繁忙的时候，挂了，重启的场景）")]),_._v(" "),v("p",[_._v("3.刷盘，checkpoint")]),_._v(" "),v("p",[_._v("避免")]),_._v(" "),v("p",[_._v("无解")]),_._v(" "),v("p",[_._v("配置较大的shared buffer")]),_._v(" "),v("p",[_._v("shared_buffer")]),_._v(" "),v("p",[_._v("设置为物理内存的25%，服务器的内存为8G，故将此选项设置为1G：")]),_._v(" "),v("p",[_._v("shared_buffers = 2048MB")]),_._v(" "),v("h2",{attrs:{id:"postgresql中xid"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#postgresql中xid"}},[_._v("#")]),_._v(" postgresql中xid")]),_._v(" "),v("p",[_._v("32xid事务号")]),_._v(" "),v("p",[_._v("7个问题")]),_._v(" "),v("p",[_._v("1问题是什么")]),_._v(" "),v("p",[_._v("事务号unit无符号整型,可以存储40亿个value,最多40亿个事务号")]),_._v(" "),v("p",[_._v("只有循环使用")]),_._v(" "),v("p",[_._v("2问题点背后涉及的技术原理")]),_._v(" "),v("p",[_._v("每一行的头部信息里面都会存储这由哪个事务id存储的，或者写入的，删除的，")]),_._v(" "),v("p",[_._v("数据库通过这个事务号判断这个事务是过去发生的还是未来发生的")]),_._v(" "),v("p",[_._v("大于当前的事务号，就是未来的事务号，大于未来的事务，你就是不可见的")]),_._v(" "),v("p",[_._v("比如，你现在正在查询，查询结果还没出来，又有新的数据插入，这个新的xid插入的信息，对于你的就是未来的，不可见的")]),_._v(" "),v("p",[v("img",{attrs:{src:"E:%5Cnote%5Cimage%5Cimage_42343.png",alt:""}})]),_._v(" "),v("p",[_._v("很快就耗尽，因此设置freeze xid，把圆切成两半，一半已经消耗了的，一半剩余还可以分配的，每20亿个xid都要移动")]),_._v(" "),v("p",[_._v("影响业务场景：")]),_._v(" "),v("p",[_._v("1、频繁更新插入，大批量更新会大量消耗事务号，会frozen，扫描全表产生大量IO")]),_._v(" "),v("p",[_._v("2、frozen很快的话导致剩余的可分配小于1千万的时候会告警，1百万强制数据库停库，只有执行单用户进去停库")]),_._v(" "),v("p",[_._v("3、大量的表的年龄增加，有可能所有的表在同一时间触发阈值进行frozen，导致风暴，因为所有的表都要去做全表扫描，")]),_._v(" "),v("p",[_._v("主库io性能暴增，产生大量wal日志，导致性能问题，同时从库的延时增加")]),_._v(" "),v("p",[_._v("业务上避免")]),_._v(" "),v("p",[_._v("1.pg内核的优化，不频繁更新的话扫描一次就搞定，对于已经frozen的page直接跳过")]),_._v(" "),v("p",[_._v("2.海量静态数据写入的时候，直接设置标记位，不需要froze")]),_._v(" "),v("p",[_._v("3.好硬盘")]),_._v(" "),v("p",[_._v("4.设置vacuum_sleep的间隙，降低IO")]),_._v(" "),v("p",[_._v("5.针对不同分区设置阈值，错开执行frozen")]),_._v(" "),v("p",[_._v("参考文章")]),_._v(" "),v("p",[_._v("https://blog.csdn.net/weixin_42474537/article/details/113010217")]),_._v(" "),v("p",[_._v("为了避坑有没有引入新的问题")]),_._v(" "),v("p",[_._v("1.管理成本，硬件成本增加")]),_._v(" "),v("p",[_._v("未来怎么修复")]),_._v(" "),v("p",[_._v("支持64位xid")]),_._v(" "),v("p",[_._v("end")]),_._v(" "),v("p",[_._v("如何安装插件")]),_._v(" "),v("p",[v("img",{attrs:{src:"/image-20220330223959328.png",alt:"image-20220330223959328"}})]),_._v(" "),v("p",[_._v("http://www.bubuko.com/infodetail-910812.html")])])}),[],!1,null,null,null);v.default=t.exports}}]);