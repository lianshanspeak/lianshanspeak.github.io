(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{976:function(a,t,e){"use strict";e.r(t);var r=e(6),s=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"大批量单表导入数据引发性能故障"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大批量单表导入数据引发性能故障"}},[a._v("#")]),a._v(" 大批量单表导入数据引发性能故障")]),a._v(" "),t("p",[a._v("现象：服务器卡死，但cpu利用率不高，free查看内存耗尽\n判断是否有大量数据导入操作，有先删除索引，在进行数据导入")]),a._v(" "),t("h2",{attrs:{id:"pg-double-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pg-double-cache"}},[a._v("#")]),a._v(" pg_double_cache")]),a._v(" "),t("p",[a._v("读取数据块的时候会占用2份内存。缓存，就是内存会在os的page cache和数据库的buffer库里面会体现出来。存在内存浪费")]),a._v(" "),t("h3",{attrs:{id:"技术原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#技术原理"}},[a._v("#")]),a._v(" "),t("strong",[a._v("技术原理")])]),a._v(" "),t("p",[a._v("pg写操作用了buffer IO 的接口，到os层会产生缓存，最后由io子系统写入到块设备里面去，读操作类似")]),a._v(" "),t("h3",{attrs:{id:"影响行业或导致问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#影响行业或导致问题"}},[a._v("#")]),a._v(" "),t("strong",[a._v("影响行业或导致问题")])]),a._v(" "),t("p",[a._v("所有行业，内存浪费\nos的buffer IO,调度配置不好的话，对导致大量IO,IO hang，导致checkpoint，和别的的读数据的响应时间")]),a._v(" "),t("p",[a._v("始终要过一次层os cache")]),a._v(" "),t("h3",{attrs:{id:"解决方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[a._v("#")]),a._v(" "),t("strong",[a._v("解决方法")])]),a._v(" "),t("p",[a._v("好处\n1.会在os层合并之后在写入，减少总的io次数\n2.数据库在重启的时候可以缓冲一下,在发起读请求的时候其实是从os层面cache读出来的，（业务繁忙的时候，挂了，重启的场景）\n3.刷盘，checkpoint")]),a._v(" "),t("p",[a._v("避免\n无解。配置较大的shared buffer")]),a._v(" "),t("p",[a._v("shared_buffer\n设置为物理内存的25%，服务器的内存为8G，故将此选项设置为1G：\nshared_buffers = 2048MB")]),a._v(" "),t("h2",{attrs:{id:"pg-local-memory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pg-local-memory"}},[a._v("#")]),a._v(" pg_local_memory")]),a._v(" "),t("p",[a._v("plan cachae")]),a._v(" "),t("h3",{attrs:{id:"背后原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背后原理"}},[a._v("#")]),a._v(" "),t("strong",[a._v("背后原理")])]),a._v(" "),t("p",[a._v("sql执行的几个阶段\n1解析：有没有语法错误，规整化\n2query的rewrit\n前面")]),a._v(" "),t("p",[t("strong",[a._v("解析计划")]),a._v("\n执行\n在会话里面是私有的")]),a._v(" "),t("h3",{attrs:{id:"影响行业"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#影响行业"}},[a._v("#")]),a._v(" "),t("strong",[a._v("影响行业")])]),a._v(" "),t("p",[a._v("1SaaS\n2分区超多的场景，要使用长连接的场景\n3微服务")]),a._v(" "),t("h3",{attrs:{id:"使用local-memory带来的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用local-memory带来的问题"}},[a._v("#")]),a._v(" "),t("strong",[a._v("使用local memory带来的问题")])]),a._v(" "),t("p",[a._v("saas：提供软件服务，有一套独立的schema，服务1w家企业的话有可能有1w个schema，每个schema可能有上万的表或对象，就很多了\n一个会话生命周期内访问很多表，数据库对象，就会产生很多的loacl cache就是local 的memory包括plan cache,占用的内存会越来越大，最后导致omm\n分区超多，要使用长连接，\n频繁更新c端的业务系统通常就有这些特性，比如共享单车数量多，用户多，通过分区提高freeze的效率，一个连接可能到\n很多的分区，消耗的内存就很多\n微服务\n对业务灵活，对于数据库来将，每一个服务都要跟数据库产生连接")]),a._v(" "),t("h3",{attrs:{id:"业务上如何避免这个坑"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#业务上如何避免这个坑"}},[a._v("#")]),a._v(" "),t("strong",[a._v("业务上如何避免这个坑")])]),a._v(" "),t("p",[a._v("1、设置会话的连接生命周期，避免长时间使用过多的对象\n2、控制总的连接数\n3、避免访问分区过度，原始的即便访问分区，也要把所有的全部touch出来\n4、创建一个中间连接池，控制总的连接数，pgbouncer（牺牲短频快）")]),a._v(" "),t("p",[a._v("会引入什么新的问题，产生什么样的牺牲\n1.增加复杂度\n2.微服务很多的时候控制总连接数")]),a._v(" "),t("p",[a._v("未来\n1.内置线程池\n2.local memory作成global memory")]),a._v(" "),t("h2",{attrs:{id:"pg-log-statement参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pg-log-statement参数"}},[a._v("#")]),a._v(" pg_log_statement参数")]),a._v(" "),t("p",[a._v("log_statements")]),a._v(" "),t("p",[a._v("有效值none(off),ddl,mod,all\nddl记录数据定义语句，create,alter,drop\nmod:所有ddl以及数据修改语句\n查看 show log_statement;\n修改会话级别\nset log_statement = none;")]),a._v(" "),t("h2",{attrs:{id:"大批量单表导入数据引发性能故障-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大批量单表导入数据引发性能故障-2"}},[a._v("#")]),a._v(" 大批量单表导入数据引发性能故障")]),a._v(" "),t("p",[a._v("现象：服务器卡死，但cpu利用率不高，free查看内存耗尽\n判断是否有大量数据导入操作，有先删除索引，在进行数据导入")]),a._v(" "),t("p",[a._v("pg_double_cache")])])}),[],!1,null,null,null);t.default=s.exports}}]);