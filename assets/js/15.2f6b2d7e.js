(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{1001:function(a,v,_){"use strict";_.r(v);var t=_(6),s=Object(t.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("p",[a._v("理解时间片轮转，同一时刻只能做一个任务")]),a._v(" "),v("p",[a._v("优先级调度算法")]),a._v(" "),v("p",[a._v("并行：多个任务一起再跑")]),a._v(" "),v("p",[a._v("并发：假的多任务，cpu数量小于任务数量")]),a._v(" "),v("p",[a._v("什么是线程")]),a._v(" "),v("p",[a._v("实现多任务的一个手段")]),a._v(" "),v("p",[a._v("当调用Thread的时候不会创建线程，")]),a._v(" "),v("p",[a._v("当调用Thread创建出来的实例对象的start方法的时候才会创建线程以及让这个线程开始运行")]),a._v(" "),v("p",[a._v("线程结束函数结束，不能确定哪个子线程先执行。")]),a._v(" "),v("p",[a._v("类的三大特性，封装，继承，多态")]),a._v(" "),v("p",[a._v("定义一个类继承Thread,会自动调用run方法，run方法作完，子线程结束。封装成类")]),a._v(" "),v("p",[v("img",{attrs:{src:_(493),alt:"image-20221127162837247"}})]),a._v(" "),v("p",[v("img",{attrs:{src:_(494),alt:"image-20221127163339249"}})]),a._v(" "),v("p",[a._v("多个线程之间共享全局变量")]),a._v(" "),v("h2",{attrs:{id:"什么时候需要加上global"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么时候需要加上global"}},[a._v("#")]),a._v(" 什么时候需要加上global")]),a._v(" "),v("p",[a._v("在一个函数中对全局变量进行修改的时候是否要加gloabl进行说明")]),a._v(" "),v("p",[a._v("要看，是否对全局变量的指向进行修改。")]),a._v(" "),v("p",[a._v("如果执向了新的地方，必须使用global，")]),a._v(" "),v("p",[a._v("如果仅仅修改了指向空间的数据，此时不用")]),a._v(" "),v("h2",{attrs:{id:"资源竞争"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#资源竞争"}},[a._v("#")]),a._v(" 资源竞争")]),a._v(" "),v("p",[a._v("如果多线程里变共享全局变量，同一时刻都在对全局变量写操作，可能会出问题")]),a._v(" "),v("p",[v("img",{attrs:{src:_(495),alt:"image-20221127212324225"}})]),a._v(" "),v("p",[a._v("同步的概念")]),a._v(" "),v("p",[a._v("协同一起做事情")]),a._v(" "),v("p",[a._v("互斥锁")]),a._v(" "),v("p",[a._v("当多个线程同时修改一个共享数据的时候，需要进行同步控制")]),a._v(" "),v("p",[a._v("某个线程要更改共享数据时，先将其”锁定“状态;其他线程不能更改,直到该线程释放资源，将状态改为非锁定，其他资源才能用")]),a._v(" "),v("h2",{attrs:{id:"如何创建互斥锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何创建互斥锁"}},[a._v("#")]),a._v(" 如何创建互斥锁")]),a._v(" "),v("p",[a._v("创建锁")]),a._v(" "),v("p",[a._v("mutex = threading.Lock()")]),a._v(" "),v("p",[a._v("锁定")]),a._v(" "),v("p",[a._v("mutex.acquire()")]),a._v(" "),v("p",[a._v("释放")]),a._v(" "),v("p",[a._v("mutex.release()")]),a._v(" "),v("h2",{attrs:{id:"死锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[a._v("#")]),a._v(" 死锁")]),a._v(" "),v("p",[a._v("两个线程分别占有一部分资源变并且同时等待对方的资源。就会造成死锁")]),a._v(" "),v("h2",{attrs:{id:"避免死锁的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#避免死锁的方法"}},[a._v("#")]),a._v(" 避免死锁的方法")]),a._v(" "),v("p",[a._v("银行家算法")]),a._v(" "),v("p",[a._v("添加超时时间")]),a._v(" "),v("p",[a._v("银行家算法")]),a._v(" "),v("p",[v("img",{attrs:{src:_(496),alt:"image-20221127215946174"}})]),a._v(" "),v("h2",{attrs:{id:"多任务udp聊天器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多任务udp聊天器"}},[a._v("#")]),a._v(" 多任务udp聊天器")])])}),[],!1,null,null,null);v.default=s.exports},493:function(a,v,_){a.exports=_.p+"assets/img/image-20221127162837247.da2a44a3.png"},494:function(a,v,_){a.exports=_.p+"assets/img/image-20221127163339249.d0fd4926.png"},495:function(a,v,_){a.exports=_.p+"assets/img/image-20221127212324225.6a2a19fa.png"},496:function(a,v,_){a.exports=_.p+"assets/img/image-20221127215946174.5544e4f7.png"}}]);